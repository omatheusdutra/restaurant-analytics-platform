import { register, login, getProfile, updateProfile, changePassword } from '@/controllers/authController';
import prisma from '@/config/database';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

jest.mock('@/config/database', () => ({
  __esModule: true,
  default: {
    user: {
      findUnique: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
    },
  },
}));

jest.mock('bcryptjs', () => ({
  __esModule: true,
  default: {
    hash: jest.fn(async () => 'hash'),
    compare: jest.fn(async () => true),
  },
}));

jest.mock('jsonwebtoken', () => ({
  __esModule: true,
  default: {
    sign: jest.fn(() => 'token'),
  },
}));

function mockRes() {
  const res: any = {};
  res.status = jest.fn().mockReturnValue(res);
  res.json = jest.fn().mockReturnValue(res);
  return res;
}

describe('authController unit', () => {
  beforeEach(() => jest.clearAllMocks());

  it('register returns 400 when user already exists', async () => {
    (prisma as any).user.findUnique.mockResolvedValueOnce({ id: 1 });
    const req: any = { body: { email: 'a@a.com', password: '123456', name: 'A' } };
    const res = mockRes();
    await register(req, res as any);
    expect(res.status).toHaveBeenCalledWith(400);
  });

  it('register success returns 201 with token', async () => {
    (prisma as any).user.findUnique.mockResolvedValueOnce(null);
    (prisma as any).user.create.mockResolvedValueOnce({ id: 1, email: 'a@a.com', name: 'A' });
    const req: any = { body: { email: 'a@a.com', password: '123456', name: 'A' } };
    const res = mockRes();
    await register(req as any, res as any);
    expect(res.status).toHaveBeenCalledWith(201);
    expect(res.json).toHaveBeenCalledWith(expect.objectContaining({ token: expect.any(String) }));
  });

  it('register handles prisma error (500)', async () => {
    (prisma as any).user.findUnique.mockResolvedValueOnce(null);
    (prisma as any).user.create.mockRejectedValueOnce(new Error('db'));
    const req: any = { body: { email: 'a@a.com', password: '123456', name: 'A' } };
    const res = mockRes();
    await register(req, res as any);
    expect(res.status).toHaveBeenCalledWith(500);
  });

  it('login handles prisma error (500)', async () => {
    (prisma as any).user.findUnique.mockRejectedValueOnce(new Error('db'));
    const req: any = { body: { email: 'a@a.com', password: '123456' } };
    const res = mockRes();
    await login(req, res as any);
    expect(res.status).toHaveBeenCalledWith(500);
  });

  it('login success returns user and token', async () => {
    (prisma as any).user.findUnique.mockResolvedValueOnce({ id: 1, email: 'a@a.com', name: 'A', password: 'hash' });
    (bcrypt as any).compare.mockResolvedValueOnce(true);
    const req: any = { body: { email: 'a@a.com', password: '123456' } };
    const res = mockRes();
    await login(req as any, res as any);
    expect(res.json).toHaveBeenCalledWith(expect.objectContaining({ token: expect.any(String) }));
  });

  it('login 401 when user not found', async () => {
    (prisma as any).user.findUnique.mockResolvedValueOnce(null);
    const req: any = { body: { email: 'a@a.com', password: '123456' } };
    const res = mockRes();
    await login(req as any, res as any);
    expect(res.status).toHaveBeenCalledWith(401);
  });

  it('login 401 when password invalid', async () => {
    (prisma as any).user.findUnique.mockResolvedValueOnce({ id: 1, password: 'hash' });
    (bcrypt as any).compare.mockResolvedValueOnce(false);
    const req: any = { body: { email: 'a@a.com', password: 'bad' } };
    const res = mockRes();
    await login(req as any, res as any);
    expect(res.status).toHaveBeenCalledWith(401);
  });

  it('getProfile 404 when user not found', async () => {
    (prisma as any).user.findUnique.mockResolvedValueOnce(null);
    const req: any = { userId: 999 };
    const res = mockRes();
    await getProfile(req, res as any);
    expect(res.status).toHaveBeenCalledWith(404);
  });

  it('getProfile 500 on prisma error', async () => {
    (prisma as any).user.findUnique.mockRejectedValueOnce(new Error('db'));
    const req: any = { userId: 1 };
    const res = mockRes();
    await getProfile(req, res as any);
    expect(res.status).toHaveBeenCalledWith(500);
  });

  it('getProfile success', async () => {
    (prisma as any).user.findUnique.mockResolvedValueOnce({ id: 1, email: 'a@a.com', name: 'A', createdAt: new Date() });
    const req: any = { userId: 1 };
    const res = mockRes();
    await getProfile(req, res as any);
    expect(res.json).toHaveBeenCalledWith(expect.objectContaining({ email: 'a@a.com' }));
  });

  it('updateProfile success', async () => {
    (prisma as any).user.update.mockResolvedValueOnce({ id: 1, email: 'a@a.com', name: 'B' });
    const req: any = { userId: 1, body: { name: 'B' } };
    const res = mockRes();
    await updateProfile(req, res as any);
    expect(res.json).toHaveBeenCalledWith({ id: 1, email: 'a@a.com', name: 'B' });
  });

  

  it('changePassword 401 when current password invalid', async () => {
    (prisma as any).user.findUnique.mockResolvedValueOnce({ id: 1, password: 'hash' });
    (bcrypt as any).compare.mockResolvedValueOnce(false);
    const req: any = { userId: 1, body: { currentPassword: 'x', newPassword: '123456' } };
    const res = mockRes();
    await changePassword(req, res as any);
    expect(res.status).toHaveBeenCalledWith(401);
  });

  it('changePassword 404 when user not found', async () => {
    (prisma as any).user.findUnique.mockResolvedValueOnce(null);
    const req: any = { userId: 1, body: { currentPassword: 'x', newPassword: '123456' } };
    const res = mockRes();
    await changePassword(req, res as any);
    expect(res.status).toHaveBeenCalledWith(404);
  });

  

  it('changePassword success', async () => {
    (prisma as any).user.findUnique.mockResolvedValueOnce({ id: 1, password: 'hash' });
    (bcrypt as any).compare.mockResolvedValueOnce(true);
    (bcrypt as any).hash.mockResolvedValueOnce('h2');
    (prisma as any).user.update.mockResolvedValueOnce({});
    const req: any = { userId: 1, body: { currentPassword: 'x', newPassword: '123456' } };
    const res = mockRes();
    await changePassword(req, res as any);
    expect(res.json).toHaveBeenCalledWith({ success: true });
  });

  it('changePassword 500 on prisma error', async () => {
    (prisma as any).user.findUnique.mockResolvedValueOnce({ id: 1, password: 'hash' });
    (bcrypt as any).compare.mockResolvedValueOnce(true);
    (bcrypt as any).hash.mockResolvedValueOnce('h2');
    (prisma as any).user.update.mockRejectedValueOnce(new Error('db'));
    const req: any = { userId: 1, body: { currentPassword: 'x', newPassword: '123456' } };
    const res = mockRes();
    await changePassword(req, res as any);
    expect(res.status).toHaveBeenCalledWith(500);
  });
});

